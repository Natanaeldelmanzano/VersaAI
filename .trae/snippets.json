{
  "name": "VersaAI Global Snippets",
  "description": "Snippets globales para desarrollo rápido en VersaAI",
  "version": "1.0.0",
  
  "global_snippets": {
    "versaai_header": {
      "prefix": "vheader",
      "body": [
        "# 🚀 VersaAI - ${1:Título del Archivo}",
        "# ${2:Descripción del archivo}",
        "# Autor: ${3:Nombre del desarrollador}",
        "# Fecha: ${CURRENT_YEAR}-${CURRENT_MONTH}-${CURRENT_DATE}",
        "# Versión: ${4:1.0.0}",
        "",
        "$0"
      ],
      "description": "Header estándar para archivos de VersaAI"
    },
    
    "versaai_todo": {
      "prefix": "vtodo",
      "body": [
        "# TODO: ${1:Descripción de la tarea}",
        "# Prioridad: ${2|Alta,Media,Baja|}",
        "# Asignado: ${3:Desarrollador}",
        "# Fecha límite: ${4:YYYY-MM-DD}",
        "# Estado: ${5|Pendiente,En Progreso,Completado|}",
        "$0"
      ],
      "description": "Template para TODOs de VersaAI"
    },
    
    "versaai_function_doc": {
      "prefix": "vdoc",
      "body": [
        "\"\"\"",
        "${1:Descripción de la función}",
        "",
        "Args:",
        "    ${2:param_name} (${3:type}): ${4:Descripción del parámetro}",
        "",
        "Returns:",
        "    ${5:return_type}: ${6:Descripción del retorno}",
        "",
        "Raises:",
        "    ${7:ExceptionType}: ${8:Descripción de la excepción}",
        "",
        "Example:",
        "    >>> ${9:ejemplo_de_uso}",
        "    ${10:resultado_esperado}",
        "\"\"\"",
        "$0"
      ],
      "description": "Documentación estándar para funciones de VersaAI"
    },
    
    "versaai_api_endpoint": {
      "prefix": "vapi",
      "body": [
        "@router.${1|get,post,put,delete,patch|}(\"${2:/endpoint}\", ",
        "    summary=\"${3:Resumen del endpoint}\",",
        "    description=\"${4:Descripción detallada}\",",
        "    response_model=${5:ResponseModel},",
        "    status_code=status.HTTP_${6|200,201,204|}_${7|OK,CREATED,NO_CONTENT|}",
        ")",
        "async def ${8:function_name}(",
        "    ${9:parameters}",
        ") -> ${10:ReturnType}:",
        "    \"\"\"${11:Docstring del endpoint}\"\"\"",
        "    try:",
        "        ${12:# Lógica del endpoint}",
        "        return ${13:response}",
        "    except Exception as e:",
        "        logger.error(f\"Error en ${8:function_name}: {e}\")",
        "        raise HTTPException(",
        "            status_code=status.HTTP_500_INTERNAL_SERVER_ERROR,",
        "            detail=\"Error interno del servidor\"",
        "        )",
        "$0"
      ],
      "description": "Template para endpoints de FastAPI en VersaAI"
    },
    
    "versaai_vue_component": {
      "prefix": "vcomp",
      "body": [
        "<template>",
        "  <div class=\"${1:component-class}\">",
        "    <h2 class=\"text-2xl font-bold mb-4\">${2:Título del Componente}</h2>",
        "    ${3:<!-- Contenido del componente -->}",
        "  </div>",
        "</template>",
        "",
        "<script setup lang=\"ts\">",
        "import { ref, computed, onMounted } from 'vue'",
        "import { ${4:imports} } from '${5:@/path}'",
        "",
        "// Props",
        "interface Props {",
        "  ${6:propName}: ${7:PropType}",
        "}",
        "",
        "const props = withDefaults(defineProps<Props>(), {",
        "  ${6:propName}: ${8:defaultValue}",
        "})",
        "",
        "// Emits",
        "const emit = defineEmits<{",
        "  ${9:eventName}: [${10:eventPayload}]",
        "}>()",
        "",
        "// State",
        "const ${11:stateName} = ref(${12:initialValue})",
        "",
        "// Computed",
        "const ${13:computedName} = computed(() => {",
        "  return ${14:computation}",
        "})",
        "",
        "// Methods",
        "const ${15:methodName} = () => {",
        "  ${16:// Lógica del método}",
        "}",
        "",
        "// Lifecycle",
        "onMounted(() => {",
        "  ${17:// Lógica de montaje}",
        "})",
        "</script>",
        "",
        "<style scoped>",
        ".${1:component-class} {",
        "  ${18:/* Estilos del componente */}",
        "}",
        "</style>",
        "$0"
      ],
      "description": "Template completo para componentes Vue 3 en VersaAI"
    },
    
    "versaai_pinia_store": {
      "prefix": "vstore",
      "body": [
        "import { defineStore } from 'pinia'",
        "import { ref, computed } from 'vue'",
        "import type { ${1:StateType} } from '@/types'",
        "import { ${2:apiService} } from '@/services'",
        "",
        "export const use${3:StoreName}Store = defineStore('${4:storeName}', () => {",
        "  // State",
        "  const ${5:stateName} = ref<${6:StateType}[]>([])",
        "  const loading = ref(false)",
        "  const error = ref<string | null>(null)",
        "",
        "  // Getters",
        "  const ${7:getterName} = computed(() => {",
        "    return ${5:stateName}.value.filter(${8:filterCondition})",
        "  })",
        "",
        "  const total = computed(() => ${5:stateName}.value.length)",
        "",
        "  // Actions",
        "  const fetch${9:EntityName} = async () => {",
        "    loading.value = true",
        "    error.value = null",
        "    ",
        "    try {",
        "      const response = await ${2:apiService}.getAll()",
        "      ${5:stateName}.value = response.data",
        "    } catch (err) {",
        "      error.value = err instanceof Error ? err.message : 'Error desconocido'",
        "      console.error('Error fetching ${9:EntityName}:', err)",
        "    } finally {",
        "      loading.value = false",
        "    }",
        "  }",
        "",
        "  const create${9:EntityName} = async (data: Partial<${1:StateType}>) => {",
        "    loading.value = true",
        "    error.value = null",
        "    ",
        "    try {",
        "      const response = await ${2:apiService}.create(data)",
        "      ${5:stateName}.value.push(response.data)",
        "      return response.data",
        "    } catch (err) {",
        "      error.value = err instanceof Error ? err.message : 'Error al crear'",
        "      throw err",
        "    } finally {",
        "      loading.value = false",
        "    }",
        "  }",
        "",
        "  const update${9:EntityName} = async (id: string, data: Partial<${1:StateType}>) => {",
        "    loading.value = true",
        "    error.value = null",
        "    ",
        "    try {",
        "      const response = await ${2:apiService}.update(id, data)",
        "      const index = ${5:stateName}.value.findIndex(item => item.id === id)",
        "      if (index !== -1) {",
        "        ${5:stateName}.value[index] = response.data",
        "      }",
        "      return response.data",
        "    } catch (err) {",
        "      error.value = err instanceof Error ? err.message : 'Error al actualizar'",
        "      throw err",
        "    } finally {",
        "      loading.value = false",
        "    }",
        "  }",
        "",
        "  const delete${9:EntityName} = async (id: string) => {",
        "    loading.value = true",
        "    error.value = null",
        "    ",
        "    try {",
        "      await ${2:apiService}.delete(id)",
        "      ${5:stateName}.value = ${5:stateName}.value.filter(item => item.id !== id)",
        "    } catch (err) {",
        "      error.value = err instanceof Error ? err.message : 'Error al eliminar'",
        "      throw err",
        "    } finally {",
        "      loading.value = false",
        "    }",
        "  }",
        "",
        "  const clearError = () => {",
        "    error.value = null",
        "  }",
        "",
        "  return {",
        "    // State",
        "    ${5:stateName},",
        "    loading,",
        "    error,",
        "    ",
        "    // Getters",
        "    ${7:getterName},",
        "    total,",
        "    ",
        "    // Actions",
        "    fetch${9:EntityName},",
        "    create${9:EntityName},",
        "    update${9:EntityName},",
        "    delete${9:EntityName},",
        "    clearError",
        "  }",
        "})",
        "$0"
      ],
      "description": "Store completo de Pinia para VersaAI"
    },
    
    "versaai_test_suite": {
      "prefix": "vtest",
      "body": [
        "import { describe, it, expect, beforeEach, afterEach } from '${1|vitest,pytest|}'",
        "import { ${2:imports} } from '${3:@/path}'",
        "",
        "describe('${4:TestSuiteName}', () => {",
        "  let ${5:testVariable}: ${6:VariableType}",
        "",
        "  beforeEach(() => {",
        "    ${7:// Setup antes de cada test}",
        "    ${5:testVariable} = ${8:initialValue}",
        "  })",
        "",
        "  afterEach(() => {",
        "    ${9:// Cleanup después de cada test}",
        "  })",
        "",
        "  describe('${10:FeatureGroup}', () => {",
        "    it('should ${11:test_description}', async () => {",
        "      // Arrange",
        "      ${12:// Preparar datos de prueba}",
        "",
        "      // Act",
        "      ${13:// Ejecutar la acción a probar}",
        "",
        "      // Assert",
        "      expect(${14:result}).${15|toBe,toEqual,toContain,toBeTruthy|}(${16:expected})",
        "    })",
        "",
        "    it('should handle ${17:error_case}', async () => {",
        "      // Arrange",
        "      ${18:// Preparar caso de error}",
        "",
        "      // Act & Assert",
        "      await expect(${19:functionCall}).${20|rejects.toThrow,resolves.toBe|}(${21:expectedError})",
        "    })",
        "  })",
        "})",
        "$0"
      ],
      "description": "Suite de tests para VersaAI"
    },
    
    "versaai_error_handler": {
      "prefix": "verror",
      "body": [
        "try {",
        "    ${1:// Código que puede fallar}",
        "} catch (error) {",
        "    // Log del error",
        "    logger.error('${2:Descripción del error}:', {",
        "        error: error.message,",
        "        stack: error.stack,",
        "        context: {",
        "            ${3:contextData}",
        "        }",
        "    })",
        "",
        "    // Manejo específico del error",
        "    if (error instanceof ${4:SpecificError}) {",
        "        ${5:// Manejo específico}",
        "    } else {",
        "        ${6:// Manejo genérico}",
        "    }",
        "",
        "    // Re-throw si es necesario",
        "    throw new ${7:CustomError}('${8:Error message}', {",
        "        cause: error,",
        "        code: '${9:ERROR_CODE}'",
        "    })",
        "}",
        "$0"
      ],
      "description": "Manejo de errores estándar para VersaAI"
    },
    
    "versaai_logger": {
      "prefix": "vlog",
      "body": [
        "import logging",
        "from src.core.logging import get_logger",
        "",
        "logger = get_logger(__name__)",
        "",
        "# Diferentes niveles de logging",
        "logger.debug('${1:Debug message}', extra={'${2:context_key}': ${3:context_value}})",
        "logger.info('${4:Info message}', extra={'${5:context_key}': ${6:context_value}})",
        "logger.warning('${7:Warning message}', extra={'${8:context_key}': ${9:context_value}})",
        "logger.error('${10:Error message}', extra={'${11:context_key}': ${12:context_value}})",
        "logger.critical('${13:Critical message}', extra={'${14:context_key}': ${15:context_value}})",
        "$0"
      ],
      "description": "Configuración de logging para VersaAI"
    },
    
    "versaai_config": {
      "prefix": "vconfig",
      "body": [
        "from pydantic import BaseSettings, Field",
        "from typing import Optional",
        "",
        "class ${1:ConfigName}Settings(BaseSettings):",
        "    \"\"\"${2:Descripción de la configuración}\"\"\"",
        "    ",
        "    # ${3:Categoría de configuración}",
        "    ${4:setting_name}: ${5:str} = Field(",
        "        default=${6:default_value},",
        "        description=\"${7:Descripción del setting}\",",
        "        env=\"${8:ENV_VAR_NAME}\"",
        "    )",
        "    ",
        "    ${9:optional_setting}: Optional[${10:int}] = Field(",
        "        default=None,",
        "        description=\"${11:Descripción del setting opcional}\",",
        "        env=\"${12:OPTIONAL_ENV_VAR}\"",
        "    )",
        "",
        "    class Config:",
        "        env_file = \".env\"",
        "        env_file_encoding = \"utf-8\"",
        "        case_sensitive = True",
        "",
        "# Instancia global de configuración",
        "${13:config_instance} = ${1:ConfigName}Settings()",
        "$0"
      ],
      "description": "Configuración con Pydantic para VersaAI"
    }
  },
  
  "versaai_specific_snippets": {
    "versaai_auth_endpoint": {
      "prefix": "vauth",
      "body": [
        "@router.post('/auth/${1|login,register,refresh,logout|}', ",
        "    summary='${2:Autenticación de usuario}',",
        "    description='${3:Endpoint para autenticación en VersaAI}',",
        "    response_model=${4:AuthResponse},",
        "    status_code=status.HTTP_200_OK",
        ")",
        "async def ${5:auth_function}(",
        "    request: ${6:AuthRequest},",
        "    db: Session = Depends(get_db),",
        "    current_user: Optional[User] = Depends(get_current_user_optional)",
        ") -> ${4:AuthResponse}:",
        "    \"\"\"${7:Descripción del endpoint de autenticación}\"\"\"    ",
        "    try:",
        "        # Validar credenciales",
        "        user = await auth_service.${8:authenticate_user}(",
        "            db=db,",
        "            email=request.email,",
        "            password=request.password",
        "        )",
        "        ",
        "        if not user:",
        "            raise HTTPException(",
        "                status_code=status.HTTP_401_UNAUTHORIZED,",
        "                detail='Credenciales inválidas',",
        "                headers={'WWW-Authenticate': 'Bearer'}",
        "            )",
        "        ",
        "        # Generar tokens",
        "        access_token = create_access_token(",
        "            data={'sub': user.email, 'user_id': str(user.id)}",
        "        )",
        "        refresh_token = create_refresh_token(",
        "            data={'sub': user.email, 'user_id': str(user.id)}",
        "        )",
        "        ",
        "        # Actualizar último login",
        "        await user_service.update_last_login(db, user.id)",
        "        ",
        "        logger.info(f'Usuario {user.email} autenticado exitosamente')",
        "        ",
        "        return ${4:AuthResponse}(",
        "            access_token=access_token,",
        "            refresh_token=refresh_token,",
        "            token_type='bearer',",
        "            user=UserResponse.from_orm(user)",
        "        )",
        "        ",
        "    except HTTPException:",
        "        raise",
        "    except Exception as e:",
        "        logger.error(f'Error en autenticación: {e}')",
        "        raise HTTPException(",
        "            status_code=status.HTTP_500_INTERNAL_SERVER_ERROR,",
        "            detail='Error interno del servidor'",
        "        )",
        "$0"
      ],
      "description": "Endpoint completo de autenticación para VersaAI"
    },
    
    "versaai_chat_endpoint": {
      "prefix": "vchat",
      "body": [
        "@router.post('/chat/${1|send,stream,history|}',",
        "    summary='${2:Funcionalidad de chat con IA}',",
        "    description='${3:Endpoint para interacción con chatbot de VersaAI}',",
        "    response_model=${4:ChatResponse}",
        ")",
        "async def ${5:chat_function}(",
        "    request: ${6:ChatRequest},",
        "    db: Session = Depends(get_db),",
        "    current_user: User = Depends(get_current_user)",
        ") -> ${4:ChatResponse}:",
        "    \"\"\"${7:Descripción del endpoint de chat}\"\"\"    ",
        "    try:",
        "        # Validar límites de usuario",
        "        await chat_service.validate_user_limits(db, current_user.id)",
        "        ",
        "        # Obtener o crear conversación",
        "        conversation = await conversation_service.get_or_create(",
        "            db=db,",
        "            user_id=current_user.id,",
        "            conversation_id=request.conversation_id",
        "        )",
        "        ",
        "        # Procesar mensaje con IA",
        "        ai_response = await groq_service.generate_response(",
        "            message=request.message,",
        "            conversation_history=conversation.messages,",
        "            user_context=current_user.preferences,",
        "            model='${8|llama-3.1-70b-versatile,mixtral-8x7b-32768|}'",
        "        )",
        "        ",
        "        # Guardar mensajes en BD",
        "        user_message = await message_service.create(",
        "            db=db,",
        "            conversation_id=conversation.id,",
        "            content=request.message,",
        "            role='user',",
        "            user_id=current_user.id",
        "        )",
        "        ",
        "        ai_message = await message_service.create(",
        "            db=db,",
        "            conversation_id=conversation.id,",
        "            content=ai_response.content,",
        "            role='assistant',",
        "            metadata=ai_response.metadata",
        "        )",
        "        ",
        "        # Actualizar estadísticas",
        "        await analytics_service.track_chat_interaction(",
        "            user_id=current_user.id,",
        "            tokens_used=ai_response.tokens_used,",
        "            model_used=ai_response.model",
        "        )",
        "        ",
        "        logger.info(f'Chat procesado para usuario {current_user.id}')",
        "        ",
        "        return ${4:ChatResponse}(",
        "            message_id=ai_message.id,",
        "            content=ai_response.content,",
        "            conversation_id=conversation.id,",
        "            tokens_used=ai_response.tokens_used,",
        "            model_used=ai_response.model,",
        "            timestamp=ai_message.created_at",
        "        )",
        "        ",
        "    except Exception as e:",
        "        logger.error(f'Error en chat: {e}')",
        "        raise HTTPException(",
        "            status_code=status.HTTP_500_INTERNAL_SERVER_ERROR,",
        "            detail='Error procesando mensaje'",
        "        )",
        "$0"
      ],
      "description": "Endpoint completo de chat con IA para VersaAI"
    },
    
    "versaai_file_upload": {
      "prefix": "vupload",
      "body": [
        "@router.post('/files/upload',",
        "    summary='${1:Subida de archivos}',",
        "    description='${2:Endpoint para subir archivos a VersaAI}',",
        "    response_model=${3:FileUploadResponse}",
        ")",
        "async def upload_file(",
        "    file: UploadFile = File(...),",
        "    file_type: str = Form(...),",
        "    description: Optional[str] = Form(None),",
        "    db: Session = Depends(get_db),",
        "    current_user: User = Depends(get_current_user)",
        ") -> ${3:FileUploadResponse}:",
        "    \"\"\"${4:Descripción del endpoint de subida}\"\"\"    ",
        "    try:",
        "        # Validar archivo",
        "        await file_service.validate_file(",
        "            file=file,",
        "            allowed_types=['${5|pdf,docx,txt,csv,xlsx|}'],",
        "            max_size_mb=${6:10}",
        "        )",
        "        ",
        "        # Validar límites de usuario",
        "        await file_service.validate_user_storage_limits(",
        "            db=db,",
        "            user_id=current_user.id,",
        "            file_size=file.size",
        "        )",
        "        ",
        "        # Generar nombre único",
        "        file_id = str(uuid.uuid4())",
        "        file_extension = Path(file.filename).suffix",
        "        unique_filename = f'{file_id}{file_extension}'",
        "        ",
        "        # Determinar directorio de destino",
        "        upload_dir = get_upload_directory(file_type, current_user.id)",
        "        file_path = upload_dir / unique_filename",
        "        ",
        "        # Guardar archivo físicamente",
        "        await file_service.save_file(file, file_path)",
        "        ",
        "        # Procesar archivo si es necesario",
        "        processed_content = None",
        "        if file_type in ['pdf', 'docx', 'txt']:",
        "            processed_content = await document_processor.extract_text(",
        "                file_path=file_path,",
        "                file_type=file_extension",
        "            )",
        "        ",
        "        # Guardar metadata en BD",
        "        file_record = await file_service.create_file_record(",
        "            db=db,",
        "            user_id=current_user.id,",
        "            filename=file.filename,",
        "            unique_filename=unique_filename,",
        "            file_path=str(file_path),",
        "            file_size=file.size,",
        "            file_type=file_type,",
        "            mime_type=file.content_type,",
        "            description=description,",
        "            processed_content=processed_content",
        "        )",
        "        ",
        "        # Generar embeddings si es documento de texto",
        "        if processed_content:",
        "            await vector_service.generate_embeddings(",
        "                file_id=file_record.id,",
        "                content=processed_content",
        "            )",
        "        ",
        "        logger.info(f'Archivo subido exitosamente: {file.filename}')",
        "        ",
        "        return ${3:FileUploadResponse}(",
        "            file_id=file_record.id,",
        "            filename=file.filename,",
        "            file_size=file.size,",
        "            file_type=file_type,",
        "            upload_url=f'/files/{file_record.id}',",
        "            processed=bool(processed_content),",
        "            created_at=file_record.created_at",
        "        )",
        "        ",
        "    except ValidationError as e:",
        "        raise HTTPException(",
        "            status_code=status.HTTP_400_BAD_REQUEST,",
        "            detail=str(e)",
        "        )",
        "    except Exception as e:",
        "        logger.error(f'Error subiendo archivo: {e}')",
        "        raise HTTPException(",
        "            status_code=status.HTTP_500_INTERNAL_SERVER_ERROR,",
        "            detail='Error procesando archivo'",
        "        )",
        "$0"
      ],
      "description": "Endpoint completo de subida de archivos para VersaAI"
    },
    "auth_endpoint": {
      "prefix": "vauth",
      "body": [
        "@router.post('/auth/${1:endpoint}', response_model=${2:ResponseModel})",
        "async def ${3:function_name}(",
        "    request: ${4:RequestModel},",
        "    db: Session = Depends(get_db),",
        "    current_user: User = Depends(get_current_user)",
        ") -> ${2:ResponseModel}:",
        "    \"\"\"${5:Endpoint description}\"\"\"\n",
        "    try:",
        "        # Validar permisos",
        "        if not current_user.is_active:",
        "            raise HTTPException(",
        "                status_code=status.HTTP_403_FORBIDDEN,",
        "                detail=\"Usuario inactivo\"",
        "            )",
        "        ",
        "        # Lógica del endpoint",
        "        ${6:# Implementar lógica}",
        "        ",
        "        return ${7:response_object}",
        "    except HTTPException:",
        "        raise",
        "    except Exception as e:",
        "        logger.error(f\"Error en ${3:function_name}: {e}\")",
        "        raise HTTPException(",
        "            status_code=status.HTTP_500_INTERNAL_SERVER_ERROR,",
        "            detail=\"Error interno del servidor\"",
        "        )",
        "$0"
      ],
      "description": "Endpoint de autenticación para VersaAI"
    },
    
    "chatbot_response": {
      "prefix": "vchat",
      "body": [
        "async def generate_chatbot_response(",
        "    message: str,",
        "    conversation_id: str,",
        "    user_id: str,",
        "    context: Optional[Dict] = None",
        ") -> ChatbotResponse:",
        "    \"\"\"Generar respuesta del chatbot usando Groq AI\"\"\"\n",
        "    try:",
        "        # Obtener contexto de la conversación",
        "        conversation_history = await get_conversation_history(",
        "            conversation_id, limit=10",
        "        )",
        "        ",
        "        # Preparar prompt con contexto",
        "        system_prompt = \"\"\"Eres un asistente de IA especializado en ${1:dominio}.",
        "        Proporciona respuestas útiles y precisas.\"\"\"",
        "        ",
        "        messages = [",
        "            {\"role\": \"system\", \"content\": system_prompt}",
        "        ]",
        "        ",
        "        # Agregar historial",
        "        for msg in conversation_history:",
        "            messages.append({",
        "                \"role\": \"user\" if msg.is_user else \"assistant\",",
        "                \"content\": msg.content",
        "            })",
        "        ",
        "        # Agregar mensaje actual",
        "        messages.append({\"role\": \"user\", \"content\": message})",
        "        ",
        "        # Llamar a Groq AI",
        "        response = await groq_client.chat.completions.create(",
        "            model=\"${2|llama3-8b-8192,llama3-70b-8192,mixtral-8x7b-32768|}\",",
        "            messages=messages,",
        "            max_tokens=${3:1000},",
        "            temperature=${4:0.7}",
        "        )",
        "        ",
        "        ai_response = response.choices[0].message.content",
        "        ",
        "        # Guardar en base de datos",
        "        await save_message(conversation_id, message, True, user_id)",
        "        await save_message(conversation_id, ai_response, False, None)",
        "        ",
        "        return ChatbotResponse(",
        "            message=ai_response,",
        "            conversation_id=conversation_id,",
        "            timestamp=datetime.utcnow()",
        "        )",
        "        ",
        "    except Exception as e:",
        "        logger.error(f\"Error generando respuesta: {e}\")",
        "        raise HTTPException(",
        "            status_code=status.HTTP_500_INTERNAL_SERVER_ERROR,",
        "            detail=\"Error generando respuesta\"",
        "        )",
        "$0"
      ],
      "description": "Función para generar respuestas de chatbot con Groq AI"
    },
    
    "file_upload_handler": {
      "prefix": "vupload",
      "body": [
        "@router.post('/upload/${1:file_type}', response_model=FileUploadResponse)",
        "async def upload_${2:file_name}(",
        "    file: UploadFile = File(...),",
        "    db: Session = Depends(get_db),",
        "    current_user: User = Depends(get_current_user)",
        ") -> FileUploadResponse:",
        "    \"\"\"Subir archivo ${3:description}\"\"\"\n",
        "    try:",
        "        # Validar tipo de archivo",
        "        allowed_types = [${4:\"image/jpeg\", \"image/png\", \"application/pdf\"}]",
        "        if file.content_type not in allowed_types:",
        "            raise HTTPException(",
        "                status_code=status.HTTP_400_BAD_REQUEST,",
        "                detail=f\"Tipo de archivo no permitido: {file.content_type}\"",
        "            )",
        "        ",
        "        # Validar tamaño",
        "        max_size = ${5:10} * 1024 * 1024  # ${5:10}MB",
        "        file_content = await file.read()",
        "        if len(file_content) > max_size:",
        "            raise HTTPException(",
        "                status_code=status.HTTP_413_REQUEST_ENTITY_TOO_LARGE,",
        "                detail=\"Archivo demasiado grande\"",
        "            )",
        "        ",
        "        # Generar nombre único",
        "        file_extension = file.filename.split('.')[-1]",
        "        unique_filename = f\"{uuid4()}.{file_extension}\"",
        "        file_path = f\"uploads/${6:folder}/{unique_filename}\"",
        "        ",
        "        # Crear directorio si no existe",
        "        os.makedirs(os.path.dirname(file_path), exist_ok=True)",
        "        ",
        "        # Guardar archivo",
        "        with open(file_path, \"wb\") as f:",
        "            f.write(file_content)",
        "        ",
        "        # Guardar en base de datos",
        "        db_file = FileModel(",
        "            filename=file.filename,",
        "            file_path=file_path,",
        "            content_type=file.content_type,",
        "            size=len(file_content),",
        "            user_id=current_user.id",
        "        )",
        "        db.add(db_file)",
        "        db.commit()",
        "        db.refresh(db_file)",
        "        ",
        "        return FileUploadResponse(",
        "            id=db_file.id,",
        "            filename=db_file.filename,",
        "            url=f\"/api/files/{db_file.id}\",",
        "            size=db_file.size",
        "        )",
        "        ",
        "    except HTTPException:",
        "        raise",
        "    except Exception as e:",
        "        logger.error(f\"Error subiendo archivo: {e}\")",
        "        raise HTTPException(",
        "            status_code=status.HTTP_500_INTERNAL_SERVER_ERROR,",
        "            detail=\"Error subiendo archivo\"",
        "        )",
        "$0"
      ],
      "description": "Handler para subida de archivos en VersaAI"
    },
    
    "vue_chat_component": {
      "prefix": "vchatcomp",
      "body": [
        "<template>",
        "  <div class=\"chat-container flex flex-col h-full\">",
        "    <!-- Header del chat -->",
        "    <div class=\"chat-header bg-blue-600 text-white p-4\">",
        "      <h3 class=\"text-lg font-semibold\">${1:Chat Title}</h3>",
        "      <p class=\"text-sm opacity-75\">${2:Chat Description}</p>",
        "    </div>",
        "    ",
        "    <!-- Mensajes -->",
        "    <div ",
        "      ref=\"messagesContainer\"",
        "      class=\"messages-container flex-1 overflow-y-auto p-4 space-y-4\"",
        "    >",
        "      <div ",
        "        v-for=\"message in messages\"",
        "        :key=\"message.id\"",
        "        :class=\"[",
        "          'message flex',",
        "          message.isUser ? 'justify-end' : 'justify-start'",
        "        ]\"",
        "      >",
        "        <div ",
        "          :class=\"[",
        "            'message-bubble max-w-xs lg:max-w-md px-4 py-2 rounded-lg',",
        "            message.isUser ",
        "              ? 'bg-blue-600 text-white' ",
        "              : 'bg-gray-200 text-gray-800'",
        "          ]\"",
        "        >",
        "          <p class=\"text-sm\">{{ message.content }}</p>",
        "          <span class=\"text-xs opacity-75 mt-1 block\">",
        "            {{ formatTime(message.timestamp) }}",
        "          </span>",
        "        </div>",
        "      </div>",
        "      ",
        "      <!-- Indicador de escritura -->",
        "      <div v-if=\"isTyping\" class=\"flex justify-start\">",
        "        <div class=\"bg-gray-200 rounded-lg px-4 py-2\">",
        "          <div class=\"typing-indicator\">",
        "            <span></span>",
        "            <span></span>",
        "            <span></span>",
        "          </div>",
        "        </div>",
        "      </div>",
        "    </div>",
        "    ",
        "    <!-- Input de mensaje -->",
        "    <div class=\"chat-input border-t p-4\">",
        "      <form @submit.prevent=\"sendMessage\" class=\"flex space-x-2\">",
        "        <input",
        "          v-model=\"newMessage\"",
        "          type=\"text\"",
        "          placeholder=\"Escribe tu mensaje...\"",
        "          class=\"flex-1 border rounded-lg px-3 py-2 focus:outline-none focus:ring-2 focus:ring-blue-500\"",
        "          :disabled=\"isLoading\"",
        "        />",
        "        <button",
        "          type=\"submit\"",
        "          :disabled=\"!newMessage.trim() || isLoading\"",
        "          class=\"bg-blue-600 text-white px-4 py-2 rounded-lg hover:bg-blue-700 disabled:opacity-50\"",
        "        >",
        "          <Icon name=\"send\" v-if=\"!isLoading\" />",
        "          <Icon name=\"loading\" v-else class=\"animate-spin\" />",
        "        </button>",
        "      </form>",
        "    </div>",
        "  </div>",
        "</template>",
        "",
        "<script setup lang=\"ts\">",
        "import { ref, computed, onMounted, nextTick } from 'vue'",
        "import { useChatStore } from '@/stores/chat'",
        "import { useAuthStore } from '@/stores/auth'",
        "import type { Message } from '@/types/chat'",
        "",
        "interface Props {",
        "  conversationId?: string",
        "}",
        "",
        "const props = withDefaults(defineProps<Props>(), {",
        "  conversationId: ''",
        "})",
        "",
        "const emit = defineEmits<{",
        "  messageSent: [message: Message]",
        "  messageReceived: [message: Message]",
        "}>()",
        "",
        "// Stores",
        "const chatStore = useChatStore()",
        "const authStore = useAuthStore()",
        "",
        "// State",
        "const newMessage = ref('')",
        "const messagesContainer = ref<HTMLElement>()",
        "const isLoading = ref(false)",
        "const isTyping = ref(false)",
        "",
        "// Computed",
        "const messages = computed(() => chatStore.getMessages(props.conversationId))",
        "",
        "// Methods",
        "const sendMessage = async () => {",
        "  if (!newMessage.value.trim() || isLoading.value) return",
        "  ",
        "  const messageContent = newMessage.value.trim()",
        "  newMessage.value = ''",
        "  isLoading.value = true",
        "  isTyping.value = true",
        "  ",
        "  try {",
        "    const response = await chatStore.sendMessage({",
        "      content: messageContent,",
        "      conversationId: props.conversationId,",
        "      userId: authStore.user?.id",
        "    })",
        "    ",
        "    emit('messageSent', response.userMessage)",
        "    emit('messageReceived', response.aiMessage)",
        "    ",
        "    await scrollToBottom()",
        "  } catch (error) {",
        "    console.error('Error enviando mensaje:', error)",
        "    // Manejar error",
        "  } finally {",
        "    isLoading.value = false",
        "    isTyping.value = false",
        "  }",
        "}",
        "",
        "const formatTime = (timestamp: string) => {",
        "  return new Date(timestamp).toLocaleTimeString('es-ES', {",
        "    hour: '2-digit',",
        "    minute: '2-digit'",
        "  })",
        "}",
        "",
        "const scrollToBottom = async () => {",
        "  await nextTick()",
        "  if (messagesContainer.value) {",
        "    messagesContainer.value.scrollTop = messagesContainer.value.scrollHeight",
        "  }",
        "}",
        "",
        "// Lifecycle",
        "onMounted(async () => {",
        "  if (props.conversationId) {",
        "    await chatStore.loadMessages(props.conversationId)",
        "  }",
        "  await scrollToBottom()",
        "})",
        "</script>",
        "",
        "<style scoped>",
        ".typing-indicator {",
        "  display: flex;",
        "  align-items: center;",
        "  gap: 4px;",
        "}",
        "",
        ".typing-indicator span {",
        "  width: 8px;",
        "  height: 8px;",
        "  border-radius: 50%;",
        "  background-color: #6b7280;",
        "  animation: typing 1.4s infinite ease-in-out;",
        "}",
        "",
        ".typing-indicator span:nth-child(1) {",
        "  animation-delay: -0.32s;",
        "}",
        "",
        ".typing-indicator span:nth-child(2) {",
        "  animation-delay: -0.16s;",
        "}",
        "",
        "@keyframes typing {",
        "  0%, 80%, 100% {",
        "    transform: scale(0);",
        "  }",
        "  40% {",
        "    transform: scale(1);",
        "  }",
        "}",
        "</style>",
        "$0"
      ],
      "description": "Componente de chat completo para VersaAI"
    }
  },
  
  "ai_snippets": {
    "groq_integration": {
      "prefix": "vgroq",
      "body": [
        "from groq import Groq",
        "from src.core.config import settings",
        "from src.core.logging import get_logger",
        "",
        "logger = get_logger(__name__)",
        "client = Groq(api_key=settings.GROQ_API_KEY)",
        "",
        "async def ${1:function_name}(",
        "    prompt: str,",
        "    model: str = \"${2|llama3-8b-8192,llama3-70b-8192,mixtral-8x7b-32768|}\",",
        "    max_tokens: int = ${3:1024},",
        "    temperature: float = ${4:0.7}",
        ") -> str:",
        "    \"\"\"${5:Descripción de la función de IA}\"\"\"",
        "    try:",
        "        response = await client.chat.completions.create(",
        "            model=model,",
        "            messages=[",
        "                {",
        "                    \"role\": \"system\",",
        "                    \"content\": \"${6:System prompt}\"",
        "                },",
        "                {",
        "                    \"role\": \"user\",",
        "                    \"content\": prompt",
        "                }",
        "            ],",
        "            max_tokens=max_tokens,",
        "            temperature=temperature",
        "        )",
        "        ",
        "        return response.choices[0].message.content",
        "        ",
        "    except Exception as e:",
        "        logger.error(f\"Error en Groq API: {e}\")",
        "        raise",
        "$0"
      ],
      "description": "Integración con Groq AI para VersaAI"
    },
    
    "rag_system": {
      "prefix": "vrag",
      "body": [
        "from typing import List, Dict, Any",
        "from src.services.vector_store import VectorStore",
        "from src.services.ai_service import AIService",
        "from src.core.logging import get_logger",
        "",
        "logger = get_logger(__name__)",
        "",
        "class ${1:RAGSystem}:",
        "    \"\"\"${2:Descripción del sistema RAG}\"\"\"",
        "    ",
        "    def __init__(self):",
        "        self.vector_store = VectorStore()",
        "        self.ai_service = AIService()",
        "    ",
        "    async def add_document(",
        "        self, ",
        "        content: str, ",
        "        metadata: Dict[str, Any] = None",
        "    ) -> str:",
        "        \"\"\"Agregar documento al sistema RAG\"\"\"",
        "        try:",
        "            # Procesar y vectorizar el documento",
        "            chunks = self._chunk_document(content)",
        "            document_id = await self.vector_store.add_chunks(",
        "                chunks, metadata or {}",
        "            )",
        "            ",
        "            logger.info(f\"Documento agregado: {document_id}\")",
        "            return document_id",
        "            ",
        "        except Exception as e:",
        "            logger.error(f\"Error agregando documento: {e}\")",
        "            raise",
        "    ",
        "    async def query(",
        "        self, ",
        "        question: str, ",
        "        top_k: int = ${3:5}",
        "    ) -> str:",
        "        \"\"\"Realizar consulta RAG\"\"\"",
        "        try:",
        "            # Buscar documentos relevantes",
        "            relevant_docs = await self.vector_store.similarity_search(",
        "                question, top_k=top_k",
        "            )",
        "            ",
        "            # Construir contexto",
        "            context = self._build_context(relevant_docs)",
        "            ",
        "            # Generar respuesta",
        "            prompt = f\"\"\"Contexto: {context}",
        "            ",
        "Pregunta: {question}",
        "            ",
        "Responde basándote únicamente en el contexto proporcionado.\"\"\"",
        "            ",
        "            response = await self.ai_service.generate_response(prompt)",
        "            return response",
        "            ",
        "        except Exception as e:",
        "            logger.error(f\"Error en consulta RAG: {e}\")",
        "            raise",
        "    ",
        "    def _chunk_document(self, content: str) -> List[str]:",
        "        \"\"\"Dividir documento en chunks\"\"\"",
        "        ${4:# Implementar chunking strategy}",
        "        return []",
        "    ",
        "    def _build_context(self, docs: List[Dict]) -> str:",
        "        \"\"\"Construir contexto desde documentos\"\"\"",
        "        ${5:# Implementar construcción de contexto}",
        "        return \"\"",
        "$0"
      ],
      "description": "Sistema RAG completo para VersaAI"
    }
  },
  
  "database_snippets": {
    "sqlalchemy_model": {
      "prefix": "vmodel",
      "body": [
        "from sqlalchemy import Column, Integer, String, DateTime, Boolean, Text, ForeignKey",
        "from sqlalchemy.orm import relationship",
        "from sqlalchemy.sql import func",
        "from src.database.base import Base",
        "",
        "class ${1:ModelName}(Base):",
        "    \"\"\"${2:Descripción del modelo}\"\"\"",
        "    ",
        "    __tablename__ = \"${3:table_name}\"",
        "    ",
        "    # Campos principales",
        "    id = Column(Integer, primary_key=True, index=True)",
        "    ${4:field_name} = Column(${5|String,Integer,Boolean,Text|}(${6:length}), ${7|nullable=False,nullable=True|})",
        "    ",
        "    # Timestamps",
        "    created_at = Column(DateTime(timezone=True), server_default=func.now())",
        "    updated_at = Column(DateTime(timezone=True), onupdate=func.now())",
        "    ",
        "    # Relaciones",
        "    ${8:related_field}_id = Column(Integer, ForeignKey(\"${9:related_table}.id\"))",
        "    ${8:related_field} = relationship(\"${10:RelatedModel}\", back_populates=\"${11:back_ref}\")",
        "    ",
        "    def __repr__(self):",
        "        return f\"<${1:ModelName}(id={self.id}, ${4:field_name}={self.${4:field_name}})>\"",
        "    ",
        "    def to_dict(self):",
        "        \"\"\"Convertir modelo a diccionario\"\"\"",
        "        return {",
        "            \"id\": self.id,",
        "            \"${4:field_name}\": self.${4:field_name},",
        "            \"created_at\": self.created_at.isoformat() if self.created_at else None,",
        "            \"updated_at\": self.updated_at.isoformat() if self.updated_at else None",
        "        }",
        "$0"
      ],
      "description": "Modelo SQLAlchemy para VersaAI"
    },
    
    "pydantic_schema": {
      "prefix": "vschema",
      "body": [
        "from pydantic import BaseModel, Field, validator",
        "from typing import Optional, List",
        "from datetime import datetime",
        "",
        "class ${1:SchemaName}Base(BaseModel):",
        "    \"\"\"${2:Descripción del schema base}\"\"\"",
        "    ",
        "    ${3:field_name}: ${4|str,int,bool,float|} = Field(",
        "        ..., ",
        "        description=\"${5:Descripción del campo}\",",
        "        example=\"${6:Ejemplo}\"",
        "    )",
        "    ",
        "    @validator('${3:field_name}')",
        "    def validate_${3:field_name}(cls, v):",
        "        \"\"\"Validar ${3:field_name}\"\"\"",
        "        ${7:# Lógica de validación}",
        "        return v",
        "",
        "class ${1:SchemaName}Create(${1:SchemaName}Base):",
        "    \"\"\"Schema para crear ${1:SchemaName}\"\"\"",
        "    pass",
        "",
        "class ${1:SchemaName}Update(BaseModel):",
        "    \"\"\"Schema para actualizar ${1:SchemaName}\"\"\"",
        "    ",
        "    ${3:field_name}: Optional[${4|str,int,bool,float|}] = Field(",
        "        None,",
        "        description=\"${5:Descripción del campo}\"",
        "    )",
        "",
        "class ${1:SchemaName}Response(${1:SchemaName}Base):",
        "    \"\"\"Schema de respuesta para ${1:SchemaName}\"\"\"",
        "    ",
        "    id: int",
        "    created_at: datetime",
        "    updated_at: Optional[datetime] = None",
        "    ",
        "    class Config:",
        "        from_attributes = True",
        "        json_encoders = {",
        "            datetime: lambda v: v.isoformat()",
        "        }",
        "",
        "class ${1:SchemaName}List(BaseModel):",
        "    \"\"\"Schema para lista de ${1:SchemaName}\"\"\"",
        "    ",
        "    items: List[${1:SchemaName}Response]",
        "    total: int",
        "    page: int",
        "    size: int",
        "    pages: int",
        "$0"
      ],
      "description": "Schemas Pydantic completos para VersaAI"
    }
  },
  
  "utility_snippets": {
    "async_context_manager": {
      "prefix": "vasync",
      "body": [
        "from contextlib import asynccontextmanager",
        "from typing import AsyncGenerator",
        "",
        "@asynccontextmanager",
        "async def ${1:context_manager_name}(${2:parameters}) -> AsyncGenerator[${3:YieldType}, None]:",
        "    \"\"\"${4:Descripción del context manager}\"\"\"",
        "    ${5:resource} = None",
        "    try:",
        "        # Setup",
        "        ${5:resource} = await ${6:setup_function}(${2:parameters})",
        "        logger.info(f\"${7:Resource} inicializado correctamente\")",
        "        ",
        "        yield ${5:resource}",
        "        ",
        "    except Exception as e:",
        "        logger.error(f\"Error en ${1:context_manager_name}: {e}\")",
        "        raise",
        "    finally:",
        "        # Cleanup",
        "        if ${5:resource}:",
        "            await ${8:cleanup_function}(${5:resource})",
        "            logger.info(f\"${7:Resource} limpiado correctamente\")",
        "$0"
      ],
      "description": "Context manager asíncrono para VersaAI"
    },
    
    "rate_limiter": {
      "prefix": "vrate",
      "body": [
        "import asyncio",
        "from time import time",
        "from typing import Dict, Optional",
        "from collections import defaultdict, deque",
        "",
        "class RateLimiter:",
        "    \"\"\"Rate limiter para VersaAI\"\"\"",
        "    ",
        "    def __init__(self, max_requests: int = ${1:100}, window_seconds: int = ${2:60}):",
        "        self.max_requests = max_requests",
        "        self.window_seconds = window_seconds",
        "        self.requests: Dict[str, deque] = defaultdict(deque)",
        "        self._lock = asyncio.Lock()",
        "    ",
        "    async def is_allowed(self, identifier: str) -> bool:",
        "        \"\"\"Verificar si la request está permitida\"\"\"",
        "        async with self._lock:",
        "            now = time()",
        "            window_start = now - self.window_seconds",
        "            ",
        "            # Limpiar requests antiguas",
        "            user_requests = self.requests[identifier]",
        "            while user_requests and user_requests[0] < window_start:",
        "                user_requests.popleft()",
        "            ",
        "            # Verificar límite",
        "            if len(user_requests) >= self.max_requests:",
        "                return False",
        "            ",
        "            # Agregar nueva request",
        "            user_requests.append(now)",
        "            return True",
        "    ",
        "    async def get_remaining(self, identifier: str) -> int:",
        "        \"\"\"Obtener requests restantes\"\"\"",
        "        async with self._lock:",
        "            now = time()",
        "            window_start = now - self.window_seconds",
        "            ",
        "            user_requests = self.requests[identifier]",
        "            while user_requests and user_requests[0] < window_start:",
        "                user_requests.popleft()",
        "            ",
        "            return max(0, self.max_requests - len(user_requests))",
        "$0"
      ],
      "description": "Rate limiter para APIs de VersaAI"
    }
  },
  
  "frontend_snippets": {
    "composable": {
      "prefix": "vcomposable",
      "body": [
        "import { ref, computed, onMounted, onUnmounted } from 'vue'",
        "import type { Ref } from 'vue'",
        "",
        "export function use${1:ComposableName}(${2:parameters}) {",
        "  // State",
        "  const ${3:stateName} = ref<${4:StateType}>(${5:initialValue})",
        "  const loading = ref(false)",
        "  const error = ref<string | null>(null)",
        "",
        "  // Computed",
        "  const ${6:computedName} = computed(() => {",
        "    return ${7:computation}",
        "  })",
        "",
        "  // Methods",
        "  const ${8:methodName} = async (${9:methodParams}) => {",
        "    loading.value = true",
        "    error.value = null",
        "    ",
        "    try {",
        "      ${10:// Lógica del método}",
        "      return ${11:result}",
        "    } catch (err) {",
        "      error.value = err instanceof Error ? err.message : 'Error desconocido'",
        "      throw err",
        "    } finally {",
        "      loading.value = false",
        "    }",
        "  }",
        "",
        "  const reset = () => {",
        "    ${3:stateName}.value = ${5:initialValue}",
        "    error.value = null",
        "  }",
        "",
        "  // Lifecycle",
        "  onMounted(() => {",
        "    ${12:// Setup logic}",
        "  })",
        "",
        "  onUnmounted(() => {",
        "    ${13:// Cleanup logic}",
        "  })",
        "",
        "  return {",
        "    // State",
        "    ${3:stateName},",
        "    loading,",
        "    error,",
        "    ",
        "    // Computed",
        "    ${6:computedName},",
        "    ",
        "    // Methods",
        "    ${8:methodName},",
        "    reset",
        "  }",
        "}",
        "$0"
      ],
      "description": "Composable de Vue 3 para VersaAI"
    }
  }
}