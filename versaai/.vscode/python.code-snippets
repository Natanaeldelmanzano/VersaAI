{
  "FastAPI Router with CRUD": {
    "prefix": "fastapi-crud",
    "body": [
      "from fastapi import APIRouter, Depends, HTTPException, status, Query",
      "from sqlalchemy.orm import Session",
      "from typing import List, Optional",
      "",
      "from src.database import get_db",
      "from src.models.$1 import $2",
      "from src.schemas.$1 import $2Create, $2Update, $2Response, $2List",
      "from src.services.$1_service import $2Service",
      "from src.core.auth import get_current_user",
      "from src.models.user import User",
      "",
      "router = APIRouter(",
      "    prefix=\"/$3\",",
      "    tags=[\"$3\"]",
      ")",
      "",
      "@router.get(\"/\", response_model=List[$2List])",
      "async def get_$3(",
      "    skip: int = Query(0, ge=0),",
      "    limit: int = Query(100, ge=1, le=100),",
      "    search: Optional[str] = Query(None),",
      "    db: Session = Depends(get_db),",
      "    current_user: User = Depends(get_current_user)",
      "):",
      "    \"\"\"Get all $3 with pagination and search.\"\"\"",
      "    return await $2Service.get_all(",
      "        db=db,",
      "        user_id=current_user.id,",
      "        skip=skip,",
      "        limit=limit,",
      "        search=search",
      "    )",
      "",
      "@router.get(\"/{$1_id}\", response_model=$2Response)",
      "async def get_$1(",
      "    $1_id: str,",
      "    db: Session = Depends(get_db),",
      "    current_user: User = Depends(get_current_user)",
      "):",
      "    \"\"\"Get a specific $1 by ID.\"\"\"",
      "    $1 = await $2Service.get_by_id(db=db, $1_id=$1_id, user_id=current_user.id)",
      "    if not $1:",
      "        raise HTTPException(",
      "            status_code=status.HTTP_404_NOT_FOUND,",
      "            detail=\"$2 not found\"",
      "        )",
      "    return $1",
      "",
      "@router.post(\"/\", response_model=$2Response, status_code=status.HTTP_201_CREATED)",
      "async def create_$1(",
      "    $1_data: $2Create,",
      "    db: Session = Depends(get_db),",
      "    current_user: User = Depends(get_current_user)",
      "):",
      "    \"\"\"Create a new $1.\"\"\"",
      "    return await $2Service.create(",
      "        db=db,",
      "        $1_data=$1_data,",
      "        user_id=current_user.id",
      "    )",
      "",
      "@router.put(\"/{$1_id}\", response_model=$2Response)",
      "async def update_$1(",
      "    $1_id: str,",
      "    $1_data: $2Update,",
      "    db: Session = Depends(get_db),",
      "    current_user: User = Depends(get_current_user)",
      "):",
      "    \"\"\"Update an existing $1.\"\"\"",
      "    $1 = await $2Service.update(",
      "        db=db,",
      "        $1_id=$1_id,",
      "        $1_data=$1_data,",
      "        user_id=current_user.id",
      "    )",
      "    if not $1:",
      "        raise HTTPException(",
      "            status_code=status.HTTP_404_NOT_FOUND,",
      "            detail=\"$2 not found\"",
      "        )",
      "    return $1",
      "",
      "@router.delete(\"/{$1_id}\", status_code=status.HTTP_204_NO_CONTENT)",
      "async def delete_$1(",
      "    $1_id: str,",
      "    db: Session = Depends(get_db),",
      "    current_user: User = Depends(get_current_user)",
      "):",
      "    \"\"\"Delete a $1.\"\"\"",
      "    success = await $2Service.delete(",
      "        db=db,",
      "        $1_id=$1_id,",
      "        user_id=current_user.id",
      "    )",
      "    if not success:",
      "        raise HTTPException(",
      "            status_code=status.HTTP_404_NOT_FOUND,",
      "            detail=\"$2 not found\"",
      "        )",
      "",
      "$0"
    ],
    "description": "FastAPI router with complete CRUD operations for VersaAI"
  },
  
  "SQLAlchemy Model": {
    "prefix": "sqlmodel",
    "body": [
      "from sqlalchemy import Column, String, DateTime, Text, Boolean, ForeignKey, Integer",
      "from sqlalchemy.orm import relationship",
      "from sqlalchemy.dialects.postgresql import UUID",
      "from datetime import datetime",
      "import uuid",
      "",
      "from src.database import Base",
      "",
      "class $1(Base):",
      "    __tablename__ = \"$2\"",
      "",
      "    id = Column(UUID(as_uuid=True), primary_key=True, default=uuid.uuid4, index=True)",
      "    name = Column(String(255), nullable=False, index=True)",
      "    description = Column(Text, nullable=True)",
      "    is_active = Column(Boolean, default=True, nullable=False)",
      "    ",
      "    # Timestamps",
      "    created_at = Column(DateTime, default=datetime.utcnow, nullable=False)",
      "    updated_at = Column(DateTime, default=datetime.utcnow, onupdate=datetime.utcnow, nullable=False)",
      "    ",
      "    # Foreign Keys",
      "    user_id = Column(UUID(as_uuid=True), ForeignKey(\"users.id\"), nullable=False, index=True)",
      "    organization_id = Column(UUID(as_uuid=True), ForeignKey(\"organizations.id\"), nullable=True, index=True)",
      "    ",
      "    # Relationships",
      "    user = relationship(\"User\", back_populates=\"$2\")",
      "    organization = relationship(\"Organization\", back_populates=\"$2\")",
      "    ",
      "    def __repr__(self):",
      "        return f\"<$1(id={self.id}, name='{self.name}')>\"",
      "    ",
      "    def to_dict(self):",
      "        return {",
      "            'id': str(self.id),",
      "            'name': self.name,",
      "            'description': self.description,",
      "            'is_active': self.is_active,",
      "            'created_at': self.created_at.isoformat() if self.created_at else None,",
      "            'updated_at': self.updated_at.isoformat() if self.updated_at else None,",
      "            'user_id': str(self.user_id) if self.user_id else None,",
      "            'organization_id': str(self.organization_id) if self.organization_id else None,",
      "        }",
      "",
      "$0"
    ],
    "description": "SQLAlchemy model for VersaAI with common fields"
  },
  
  "Pydantic Schema": {
    "prefix": "pydantic-schema",
    "body": [
      "from pydantic import BaseModel, Field, validator",
      "from typing import Optional, List",
      "from datetime import datetime",
      "from uuid import UUID",
      "",
      "# Base schema",
      "class $1Base(BaseModel):",
      "    name: str = Field(..., min_length=1, max_length=255, description=\"Name of the $2\")",
      "    description: Optional[str] = Field(None, max_length=1000, description=\"Description of the $2\")",
      "    is_active: bool = Field(True, description=\"Whether the $2 is active\")",
      "    ",
      "    @validator('name')",
      "    def validate_name(cls, v):",
      "        if not v or not v.strip():",
      "            raise ValueError('Name cannot be empty')",
      "        return v.strip()",
      "",
      "# Create schema",
      "class $1Create($1Base):",
      "    pass",
      "",
      "# Update schema",
      "class $1Update(BaseModel):",
      "    name: Optional[str] = Field(None, min_length=1, max_length=255)",
      "    description: Optional[str] = Field(None, max_length=1000)",
      "    is_active: Optional[bool] = None",
      "    ",
      "    @validator('name')",
      "    def validate_name(cls, v):",
      "        if v is not None and (not v or not v.strip()):",
      "            raise ValueError('Name cannot be empty')",
      "        return v.strip() if v else v",
      "",
      "# Response schema",
      "class $1Response($1Base):",
      "    id: UUID = Field(..., description=\"Unique identifier\")",
      "    user_id: UUID = Field(..., description=\"Owner user ID\")",
      "    organization_id: Optional[UUID] = Field(None, description=\"Organization ID\")",
      "    created_at: datetime = Field(..., description=\"Creation timestamp\")",
      "    updated_at: datetime = Field(..., description=\"Last update timestamp\")",
      "    ",
      "    class Config:",
      "        from_attributes = True",
      "        json_encoders = {",
      "            datetime: lambda v: v.isoformat(),",
      "            UUID: lambda v: str(v)",
      "        }",
      "",
      "# List item schema (for pagination)",
      "class $1List(BaseModel):",
      "    id: UUID",
      "    name: str",
      "    is_active: bool",
      "    created_at: datetime",
      "    ",
      "    class Config:",
      "        from_attributes = True",
      "        json_encoders = {",
      "            datetime: lambda v: v.isoformat(),",
      "            UUID: lambda v: str(v)",
      "        }",
      "",
      "# Pagination response",
      "class $1PaginatedResponse(BaseModel):",
      "    items: List[$1List]",
      "    total: int",
      "    page: int",
      "    size: int",
      "    pages: int",
      "",
      "$0"
    ],
    "description": "Pydantic schemas for VersaAI with validation"
  },
  
  "Service Layer": {
    "prefix": "service-layer",
    "body": [
      "from sqlalchemy.orm import Session",
      "from sqlalchemy import and_, or_",
      "from typing import List, Optional",
      "from uuid import UUID",
      "",
      "from src.models.$1 import $2",
      "from src.schemas.$1 import $2Create, $2Update",
      "from src.core.exceptions import NotFoundError, ValidationError",
      "from src.core.logging import get_logger",
      "",
      "logger = get_logger(__name__)",
      "",
      "class $2Service:",
      "    @staticmethod",
      "    async def get_all(",
      "        db: Session,",
      "        user_id: UUID,",
      "        skip: int = 0,",
      "        limit: int = 100,",
      "        search: Optional[str] = None,",
      "        organization_id: Optional[UUID] = None",
      "    ) -> List[$2]:",
      "        \"\"\"Get all $3 for a user with optional filtering.\"\"\"",
      "        query = db.query($2).filter($2.user_id == user_id)",
      "        ",
      "        if organization_id:",
      "            query = query.filter($2.organization_id == organization_id)",
      "        ",
      "        if search:",
      "            search_filter = or_(",
      "                $2.name.ilike(f\"%{search}%\"),",
      "                $2.description.ilike(f\"%{search}%\")",
      "            )",
      "            query = query.filter(search_filter)",
      "        ",
      "        return query.offset(skip).limit(limit).all()",
      "",
      "    @staticmethod",
      "    async def get_by_id(",
      "        db: Session,",
      "        $1_id: UUID,",
      "        user_id: UUID",
      "    ) -> Optional[$2]:",
      "        \"\"\"Get a $1 by ID for a specific user.\"\"\"",
      "        return db.query($2).filter(",
      "            and_(",
      "                $2.id == $1_id,",
      "                $2.user_id == user_id",
      "            )",
      "        ).first()",
      "",
      "    @staticmethod",
      "    async def create(",
      "        db: Session,",
      "        $1_data: $2Create,",
      "        user_id: UUID,",
      "        organization_id: Optional[UUID] = None",
      "    ) -> $2:",
      "        \"\"\"Create a new $1.\"\"\"",
      "        try:",
      "            db_$1 = $2(",
      "                **$1_data.dict(),",
      "                user_id=user_id,",
      "                organization_id=organization_id",
      "            )",
      "            ",
      "            db.add(db_$1)",
      "            db.commit()",
      "            db.refresh(db_$1)",
      "            ",
      "            logger.info(f\"Created $1 {db_$1.id} for user {user_id}\")",
      "            return db_$1",
      "            ",
      "        except Exception as e:",
      "            db.rollback()",
      "            logger.error(f\"Error creating $1: {str(e)}\")",
      "            raise ValidationError(f\"Failed to create $1: {str(e)}\")",
      "",
      "    @staticmethod",
      "    async def update(",
      "        db: Session,",
      "        $1_id: UUID,",
      "        $1_data: $2Update,",
      "        user_id: UUID",
      "    ) -> Optional[$2]:",
      "        \"\"\"Update an existing $1.\"\"\"",
      "        db_$1 = await $2Service.get_by_id(db, $1_id, user_id)",
      "        if not db_$1:",
      "            return None",
      "        ",
      "        try:",
      "            update_data = $1_data.dict(exclude_unset=True)",
      "            for field, value in update_data.items():",
      "                setattr(db_$1, field, value)",
      "            ",
      "            db.commit()",
      "            db.refresh(db_$1)",
      "            ",
      "            logger.info(f\"Updated $1 {$1_id} for user {user_id}\")",
      "            return db_$1",
      "            ",
      "        except Exception as e:",
      "            db.rollback()",
      "            logger.error(f\"Error updating $1 {$1_id}: {str(e)}\")",
      "            raise ValidationError(f\"Failed to update $1: {str(e)}\")",
      "",
      "    @staticmethod",
      "    async def delete(",
      "        db: Session,",
      "        $1_id: UUID,",
      "        user_id: UUID",
      "    ) -> bool:",
      "        \"\"\"Delete a $1.\"\"\"",
      "        db_$1 = await $2Service.get_by_id(db, $1_id, user_id)",
      "        if not db_$1:",
      "            return False",
      "        ",
      "        try:",
      "            db.delete(db_$1)",
      "            db.commit()",
      "            ",
      "            logger.info(f\"Deleted $1 {$1_id} for user {user_id}\")",
      "            return True",
      "            ",
      "        except Exception as e:",
      "            db.rollback()",
      "            logger.error(f\"Error deleting $1 {$1_id}: {str(e)}\")",
      "            raise ValidationError(f\"Failed to delete $1: {str(e)}\")",
      "",
      "    @staticmethod",
      "    async def count(",
      "        db: Session,",
      "        user_id: UUID,",
      "        organization_id: Optional[UUID] = None",
      "    ) -> int:",
      "        \"\"\"Count total $3 for a user.\"\"\"",
      "        query = db.query($2).filter($2.user_id == user_id)",
      "        ",
      "        if organization_id:",
      "            query = query.filter($2.organization_id == organization_id)",
      "        ",
      "        return query.count()",
      "",
      "$0"
    ],
    "description": "Service layer with business logic for VersaAI"
  },
  
  "Pytest Test": {
    "prefix": "pytest-test",
    "body": [
      "import pytest",
      "from fastapi.testclient import TestClient",
      "from sqlalchemy.orm import Session",
      "from uuid import uuid4",
      "",
      "from src.main import app",
      "from src.database import get_db",
      "from src.models.$1 import $2",
      "from src.models.user import User",
      "from tests.conftest import TestingSessionLocal, override_get_db",
      "from tests.utils import create_test_user, create_test_$1",
      "",
      "app.dependency_overrides[get_db] = override_get_db",
      "client = TestClient(app)",
      "",
      "class Test$2:",
      "    def setup_method(self):",
      "        \"\"\"Setup for each test method.\"\"\"",
      "        self.db = TestingSessionLocal()",
      "        self.user = create_test_user(self.db)",
      "        self.headers = {\"Authorization\": f\"Bearer {self.user.access_token}\"}",
      "",
      "    def teardown_method(self):",
      "        \"\"\"Cleanup after each test method.\"\"\"",
      "        self.db.close()",
      "",
      "    def test_create_$1_success(self):",
      "        \"\"\"Test successful $1 creation.\"\"\"",
      "        $1_data = {",
      "            \"name\": \"Test $2\",",
      "            \"description\": \"Test description\",",
      "            \"is_active\": True",
      "        }",
      "        ",
      "        response = client.post(",
      "            \"/$3/\",",
      "            json=$1_data,",
      "            headers=self.headers",
      "        )",
      "        ",
      "        assert response.status_code == 201",
      "        data = response.json()",
      "        assert data[\"name\"] == $1_data[\"name\"]",
      "        assert data[\"description\"] == $1_data[\"description\"]",
      "        assert \"id\" in data",
      "        assert \"created_at\" in data",
      "",
      "    def test_create_$1_invalid_data(self):",
      "        \"\"\"Test $1 creation with invalid data.\"\"\"",
      "        $1_data = {",
      "            \"name\": \"\",  # Empty name should fail",
      "            \"description\": \"Test description\"",
      "        }",
      "        ",
      "        response = client.post(",
      "            \"/$3/\",",
      "            json=$1_data,",
      "            headers=self.headers",
      "        )",
      "        ",
      "        assert response.status_code == 422",
      "",
      "    def test_get_$1_success(self):",
      "        \"\"\"Test successful $1 retrieval.\"\"\"",
      "        # Create a test $1",
      "        test_$1 = create_test_$1(self.db, self.user.id)",
      "        ",
      "        response = client.get(",
      "            f\"/$3/{test_$1.id}\",",
      "            headers=self.headers",
      "        )",
      "        ",
      "        assert response.status_code == 200",
      "        data = response.json()",
      "        assert data[\"id\"] == str(test_$1.id)",
      "        assert data[\"name\"] == test_$1.name",
      "",
      "    def test_get_$1_not_found(self):",
      "        \"\"\"Test $1 retrieval with non-existent ID.\"\"\"",
      "        fake_id = str(uuid4())",
      "        ",
      "        response = client.get(",
      "            f\"/$3/{fake_id}\",",
      "            headers=self.headers",
      "        )",
      "        ",
      "        assert response.status_code == 404",
      "",
      "    def test_update_$1_success(self):",
      "        \"\"\"Test successful $1 update.\"\"\"",
      "        # Create a test $1",
      "        test_$1 = create_test_$1(self.db, self.user.id)",
      "        ",
      "        update_data = {",
      "            \"name\": \"Updated $2\",",
      "            \"description\": \"Updated description\"",
      "        }",
      "        ",
      "        response = client.put(",
      "            f\"/$3/{test_$1.id}\",",
      "            json=update_data,",
      "            headers=self.headers",
      "        )",
      "        ",
      "        assert response.status_code == 200",
      "        data = response.json()",
      "        assert data[\"name\"] == update_data[\"name\"]",
      "        assert data[\"description\"] == update_data[\"description\"]",
      "",
      "    def test_delete_$1_success(self):",
      "        \"\"\"Test successful $1 deletion.\"\"\"",
      "        # Create a test $1",
      "        test_$1 = create_test_$1(self.db, self.user.id)",
      "        ",
      "        response = client.delete(",
      "            f\"/$3/{test_$1.id}\",",
      "            headers=self.headers",
      "        )",
      "        ",
      "        assert response.status_code == 204",
      "        ",
      "        # Verify $1 is deleted",
      "        get_response = client.get(",
      "            f\"/$3/{test_$1.id}\",",
      "            headers=self.headers",
      "        )",
      "        assert get_response.status_code == 404",
      "",
      "    def test_list_$3_success(self):",
      "        \"\"\"Test successful $3 listing.\"\"\"",
      "        # Create multiple test $3",
      "        for i in range(3):",
      "            create_test_$1(self.db, self.user.id, name=f\"Test $2 {i}\")",
      "        ",
      "        response = client.get(",
      "            \"/$3/\",",
      "            headers=self.headers",
      "        )",
      "        ",
      "        assert response.status_code == 200",
      "        data = response.json()",
      "        assert len(data) >= 3",
      "",
      "    def test_list_$3_with_search(self):",
      "        \"\"\"Test $3 listing with search.\"\"\"",
      "        # Create test $3 with specific names",
      "        create_test_$1(self.db, self.user.id, name=\"Searchable $2\")",
      "        create_test_$1(self.db, self.user.id, name=\"Other $2\")",
      "        ",
      "        response = client.get(",
      "            \"/$3/?search=Searchable\",",
      "            headers=self.headers",
      "        )",
      "        ",
      "        assert response.status_code == 200",
      "        data = response.json()",
      "        assert len(data) == 1",
      "        assert \"Searchable\" in data[0][\"name\"]",
      "",
      "    def test_unauthorized_access(self):",
      "        \"\"\"Test unauthorized access to $3 endpoints.\"\"\"",
      "        response = client.get(\"/$3/\")",
      "        assert response.status_code == 401",
      "",
      "$0"
    ],
    "description": "Comprehensive pytest test suite for VersaAI endpoints"
  },
  
  "Alembic Migration": {
    "prefix": "alembic-migration",
    "body": [
      "\"\"\"$1",
      "",
      "Revision ID: ${2:revision_id}",
      "Revises: ${3:previous_revision}",
      "Create Date: ${4:2024-01-01 12:00:00.000000}",
      "",
      "\"\"",
      "from alembic import op",
      "import sqlalchemy as sa",
      "from sqlalchemy.dialects import postgresql",
      "",
      "# revision identifiers, used by Alembic.",
      "revision = '$2'",
      "down_revision = '$3'",
      "branch_labels = None",
      "depends_on = None",
      "",
      "def upgrade() -> None:",
      "    # ### commands auto generated by Alembic - please adjust! ###",
      "    op.create_table('$5',",
      "        sa.Column('id', postgresql.UUID(as_uuid=True), nullable=False),",
      "        sa.Column('name', sa.String(length=255), nullable=False),",
      "        sa.Column('description', sa.Text(), nullable=True),",
      "        sa.Column('is_active', sa.Boolean(), nullable=False),",
      "        sa.Column('created_at', sa.DateTime(), nullable=False),",
      "        sa.Column('updated_at', sa.DateTime(), nullable=False),",
      "        sa.Column('user_id', postgresql.UUID(as_uuid=True), nullable=False),",
      "        sa.Column('organization_id', postgresql.UUID(as_uuid=True), nullable=True),",
      "        sa.ForeignKeyConstraint(['organization_id'], ['organizations.id'], ),",
      "        sa.ForeignKeyConstraint(['user_id'], ['users.id'], ),",
      "        sa.PrimaryKeyConstraint('id')",
      "    )",
      "    op.create_index(op.f('ix_$5_id'), '$5', ['id'], unique=False)",
      "    op.create_index(op.f('ix_$5_name'), '$5', ['name'], unique=False)",
      "    op.create_index(op.f('ix_$5_user_id'), '$5', ['user_id'], unique=False)",
      "    op.create_index(op.f('ix_$5_organization_id'), '$5', ['organization_id'], unique=False)",
      "    # ### end Alembic commands ###",
      "",
      "def downgrade() -> None:",
      "    # ### commands auto generated by Alembic - please adjust! ###",
      "    op.drop_index(op.f('ix_$5_organization_id'), table_name='$5')",
      "    op.drop_index(op.f('ix_$5_user_id'), table_name='$5')",
      "    op.drop_index(op.f('ix_$5_name'), table_name='$5')",
      "    op.drop_index(op.f('ix_$5_id'), table_name='$5')",
      "    op.drop_table('$5')",
      "    # ### end Alembic commands ###",
      "",
      "$0"
    ],
    "description": "Alembic migration template for VersaAI"
  },
  
  "VersaAI Chatbot Model": {
    "prefix": "versaai-chatbot",
    "body": [
      "from sqlalchemy import Column, String, DateTime, Text, Boolean, ForeignKey, JSON",
      "from sqlalchemy.orm import relationship",
      "from sqlalchemy.dialects.postgresql import UUID",
      "from datetime import datetime",
      "import uuid",
      "",
      "from src.database import Base",
      "",
      "class Chatbot(Base):",
      "    __tablename__ = \"chatbots\"",
      "",
      "    id = Column(UUID(as_uuid=True), primary_key=True, default=uuid.uuid4, index=True)",
      "    name = Column(String(255), nullable=False, index=True)",
      "    description = Column(Text, nullable=True)",
      "    prompt = Column(Text, nullable=False)",
      "    model = Column(String(100), nullable=False, default=\"llama3-8b-8192\")",
      "    temperature = Column(sa.Float, nullable=False, default=0.7)",
      "    max_tokens = Column(sa.Integer, nullable=False, default=1000)",
      "    is_active = Column(Boolean, default=True, nullable=False)",
      "    is_public = Column(Boolean, default=False, nullable=False)",
      "    ",
      "    # Configuration",
      "    config = Column(JSON, nullable=True, default=dict)",
      "    knowledge_base = Column(JSON, nullable=True, default=list)",
      "    ",
      "    # Timestamps",
      "    created_at = Column(DateTime, default=datetime.utcnow, nullable=False)",
      "    updated_at = Column(DateTime, default=datetime.utcnow, onupdate=datetime.utcnow, nullable=False)",
      "    ",
      "    # Foreign Keys",
      "    user_id = Column(UUID(as_uuid=True), ForeignKey(\"users.id\"), nullable=False, index=True)",
      "    organization_id = Column(UUID(as_uuid=True), ForeignKey(\"organizations.id\"), nullable=True, index=True)",
      "    ",
      "    # Relationships",
      "    user = relationship(\"User\", back_populates=\"chatbots\")",
      "    organization = relationship(\"Organization\", back_populates=\"chatbots\")",
      "    conversations = relationship(\"Conversation\", back_populates=\"chatbot\", cascade=\"all, delete-orphan\")",
      "    ",
      "    def __repr__(self):",
      "        return f\"<Chatbot(id={self.id}, name='{self.name}', model='{self.model}')>\"",
      "    ",
      "    def to_dict(self):",
      "        return {",
      "            'id': str(self.id),",
      "            'name': self.name,",
      "            'description': self.description,",
      "            'prompt': self.prompt,",
      "            'model': self.model,",
      "            'temperature': self.temperature,",
      "            'max_tokens': self.max_tokens,",
      "            'is_active': self.is_active,",
      "            'is_public': self.is_public,",
      "            'config': self.config,",
      "            'knowledge_base': self.knowledge_base,",
      "            'created_at': self.created_at.isoformat() if self.created_at else None,",
      "            'updated_at': self.updated_at.isoformat() if self.updated_at else None,",
      "            'user_id': str(self.user_id) if self.user_id else None,",
      "            'organization_id': str(self.organization_id) if self.organization_id else None,",
      "        }",
      "",
      "$0"
    ],
    "description": "VersaAI Chatbot model with AI configuration"
  },
  
  "VersaAI AI Service": {
    "prefix": "versaai-ai",
    "body": [
      "import asyncio",
      "from typing import List, Dict, Any, Optional",
      "from groq import Groq",
      "import json",
      "",
      "from src.core.config import settings",
      "from src.core.logging import get_logger",
      "from src.models.chatbot import Chatbot",
      "from src.models.conversation import Conversation, Message",
      "",
      "logger = get_logger(__name__)",
      "",
      "class AIService:",
      "    def __init__(self):",
      "        self.client = Groq(api_key=settings.GROQ_API_KEY)",
      "        self.default_model = \"llama3-8b-8192\"",
      "    ",
      "    async def generate_response(",
      "        self,",
      "        chatbot: Chatbot,",
      "        message: str,",
      "        conversation_history: List[Message] = None",
      "    ) -> str:",
      "        \"\"\"Generate AI response using Groq API.\"\"\"",
      "        try:",
      "            # Prepare conversation context",
      "            messages = self._prepare_messages(",
      "                chatbot=chatbot,",
      "                user_message=message,",
      "                history=conversation_history or []",
      "            )",
      "            ",
      "            # Call Groq API",
      "            response = await self._call_groq_api(",
      "                messages=messages,",
      "                model=chatbot.model or self.default_model,",
      "                temperature=chatbot.temperature or 0.7,",
      "                max_tokens=chatbot.max_tokens or 1000",
      "            )",
      "            ",
      "            return response",
      "            ",
      "        except Exception as e:",
      "            logger.error(f\"Error generating AI response: {str(e)}\")",
      "            return \"Lo siento, ha ocurrido un error al procesar tu mensaje. Por favor, inténtalo de nuevo.\"",
      "    ",
      "    def _prepare_messages(",
      "        self,",
      "        chatbot: Chatbot,",
      "        user_message: str,",
      "        history: List[Message]",
      "    ) -> List[Dict[str, str]]:",
      "        \"\"\"Prepare messages for Groq API.\"\"\"",
      "        messages = []",
      "        ",
      "        # Add system prompt",
      "        if chatbot.prompt:",
      "            messages.append({",
      "                \"role\": \"system\",",
      "                \"content\": chatbot.prompt",
      "            })",
      "        ",
      "        # Add knowledge base context if available",
      "        if chatbot.knowledge_base:",
      "            context = self._build_context_from_knowledge_base(",
      "                knowledge_base=chatbot.knowledge_base,",
      "                query=user_message",
      "            )",
      "            if context:",
      "                messages.append({",
      "                    \"role\": \"system\",",
      "                    \"content\": f\"Contexto relevante: {context}\"",
      "                })",
      "        ",
      "        # Add conversation history (last 10 messages)",
      "        recent_history = history[-10:] if len(history) > 10 else history",
      "        for msg in recent_history:",
      "            messages.append({",
      "                \"role\": \"user\" if msg.is_user else \"assistant\",",
      "                \"content\": msg.content",
      "            })",
      "        ",
      "        # Add current user message",
      "        messages.append({",
      "            \"role\": \"user\",",
      "            \"content\": user_message",
      "        })",
      "        ",
      "        return messages",
      "    ",
      "    async def _call_groq_api(",
      "        self,",
      "        messages: List[Dict[str, str]],",
      "        model: str,",
      "        temperature: float,",
      "        max_tokens: int",
      "    ) -> str:",
      "        \"\"\"Call Groq API asynchronously.\"\"\"",
      "        try:",
      "            # Run in thread pool since Groq client is synchronous",
      "            loop = asyncio.get_event_loop()",
      "            response = await loop.run_in_executor(",
      "                None,",
      "                lambda: self.client.chat.completions.create(",
      "                    model=model,",
      "                    messages=messages,",
      "                    temperature=temperature,",
      "                    max_tokens=max_tokens,",
      "                    stream=False",
      "                )",
      "            )",
      "            ",
      "            return response.choices[0].message.content",
      "            ",
      "        except Exception as e:",
      "            logger.error(f\"Groq API error: {str(e)}\")",
      "            raise",
      "    ",
      "    def _build_context_from_knowledge_base(",
      "        self,",
      "        knowledge_base: List[Dict[str, Any]],",
      "        query: str",
      "    ) -> str:",
      "        \"\"\"Build context from knowledge base using simple keyword matching.\"\"\"",
      "        relevant_docs = []",
      "        query_lower = query.lower()",
      "        ",
      "        for doc in knowledge_base:",
      "            if isinstance(doc, dict) and 'content' in doc:",
      "                content = doc['content'].lower()",
      "                # Simple keyword matching",
      "                if any(word in content for word in query_lower.split()):",
      "                    relevant_docs.append(doc['content'])",
      "        ",
      "        return ' '.join(relevant_docs[:3])  # Limit to 3 most relevant docs",
      "    ",
      "    async def validate_model(self, model: str) -> bool:",
      "        \"\"\"Validate if model is available in Groq.\"\"\"",
      "        available_models = [",
      "            \"llama3-8b-8192\",",
      "            \"llama3-70b-8192\",",
      "            \"mixtral-8x7b-32768\",",
      "            \"gemma-7b-it\"",
      "        ]",
      "        return model in available_models",
      "    ",
      "    async def get_available_models(self) -> List[str]:",
      "        \"\"\"Get list of available models.\"\"\"",
      "        return [",
      "            \"llama3-8b-8192\",",
      "            \"llama3-70b-8192\",",
      "            \"mixtral-8x7b-32768\",",
      "            \"gemma-7b-it\"",
      "        ]",
      "",
      "# Global AI service instance",
      "ai_service = AIService()",
      "",
      "$0"
    ],
    "description": "VersaAI AI Service with Groq integration"
  }
}